#### 垃圾收集第一步：判断对象是否可回收

1. ##### 引用计数算法

   给对象一个引用计数器，每对这个对象有一个引用，计数器就+1，当引用失效，给计数器-1，任何时候计数器为0的时候，这个对象就是不会再被使用。

   但是引用计数算法的缺点是无法解决循环引用的问题。

2. ##### 可达性分析算法

   通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到达GC Roots没有任何引用链相连，则证明此对象不可用。也就是说，遍历根节点的引用链时，每遍历一个节点则给节点做一个可达标记。当遍历完所有GC Roots时，没有标记的对象即是可以回收的对象。

   可以作为GC Roots的对象有：

   虚拟机栈（栈帧中的本地变量表）中引用的对象。

   方法区中类静态属性引用的对象。

   方法区中常量引用的对象。

   本地方法栈中JNI（一般说的Native方法）引用的对象。

   *Java GC使用的是可达性分析算法确定没有引用的对象。*

#### 垃圾收集第二步：执行finalize()方法

经过第一步，GC已经初步确定了需要回收的对象。但是并没有立刻回收，对象还有一个机会来避免被回收：finalize方法。GC会判断要回收的对象是否有必要执行finalize方法，如果没有必要执行，或者该对象的finalize已经执行过了（一个对象的finalize方法在生命周期内只能执行一次），则对象就将会被回收。如果有必要执行，这个对象将会放置在一个F-Queue队列中，并稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去依次从队列中取出对象，触发它的finalize方法，并且只负责触发，不关心它的结果。如果对象在finalize方法中重新将自己和引用链上的对象建立起引用关系，则它将取消被回收。

#### 垃圾收集第三步：具体回收算法

前两步已经完全确定下需要进行垃圾回收的对象。下面要进行的就是具体的回收步骤。

1. ##### 标记-清除算法

   Mark-Sweep算法，分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收被标记的对象。这个算法是基础算法，后续的垃圾收集算法都是基于这个思路进行的改进。该算法的缺点有：

   - 效率问题，标记和清除两个过程效率都不高；
   - 空间问题，清除之后内存中会产生大量不连续的内存碎片，碎片过多会导致如果需要分配空间较大的对象，可能会因为碎片过小而没有内存可以分配，从而提前触发一次GC。

2. ##### 复制算法

   Copying算法，将可用内存划分为大小相等的两块，每次只使用其中一块。当这块内存空间用完了，则将不需要GC回收的对象复制到另一块未被使用的内存区域上，然后把用过的内存空间一次清理掉。这样的垃圾回收比较高效，只需要挪动堆顶指针，对于堆来讲就已经完成了垃圾回收工作，不用考虑内存碎片的问题。缺点：

   - 堆可用空间将永远只有物理可用空间的一半，空间利用效率低。
   - 如果GC时对象存活率较高，则需要复制的对象过多，影响效率，使得算法的上下限依赖于对象存活率。

   但是因为新生代的对象98%都是朝生夕死的，所以在新生代，每次使用复制算法需要复制的对象比较少。因为这个原因，复制算法并不需要将整个内存空间平分，而是可以将内存氛围一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。当拷贝存活对象时，如果Survivor空间不够用，需要依赖老年代进行分配担保，也就是将放不下的对象放到老年代。

3. ##### 标记-整理算法

   针对于复制算法的缺点，根据老年代的特点，提出Mark-Compact算法。在标记-清除算法的基础上，标记之后不是直接清除内存，而是将所有存活的对象都向一端移动，然后直接清理掉边界以外的内存，需要操作内存的数量相对于复制算法有所减少，并且不需要额外的空间作为分配担保。

4. ##### 分代收集算法

   根据对象存活周期的不同将内存划分为几块。一般是将Java堆分为新生代和老年代，根据各年代特点采用适当的收集算法。

   新生代中，每次GC时都有大量对象被回收，只有少量存活，则使用复制算法。

   老年代中，因为对象存活率高，没有额外空间进行分配担保，则需要使用标记-清除或者标记-整理算法来回收。

#### 垃圾收集器

1. ##### Serial收集器

   它是最基本、历史最悠久的收集器，在JDK1.3.1之前是虚拟机新生代收集的唯一选择。它是单线程收集器，“单线程”的意思除了它只用一个CPU，或者说只用一个线程完成垃圾收集工作，更重要的是它在垃圾收集时，**必须暂停其他所有的工作线程**（stop the world），直到收集结束。Serial收集器在**新生代**采取**复制算法**，在**老年代**称为Serial Old，采用**标记-整理算法**。它的优点：

   - 在同样单线程的情况下，相比其他收集器要简单而高效。
   - 在分配内存不是很大的情况下，需要暂停所有线程的时间一般很短，对用户来讲可以接受。

   Serial收集器到现在都是Client模式下的虚拟机的默认新生代收集器。

2. ##### ParNew收集器

   它就是Serial收集器的多线程版本。也就是说，它在进行垃圾回收前，同样也会暂停所有用户线程，不过回收时是多线程并行，并且在**新生代**也采用**复制算法**。

3. ##### Parallel Scavenge收集器

   也是一个新生代收集器，并且使用复制算法，并且是并行的多线程。

   这个收集器和其他收集器不同的是，它的关注点不是尽可能缩短垃圾收集时用户线程的停顿时间，而是旨在达到一个可控制的吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），也就是垃圾收集所用的时间占虚拟机总运行时间的占比）。

   关注停顿时间适合用在与用户交互的程序中，可以提升对用户的响应速度。而高吞吐量则可以最高效率的利用CPU时间，尽快完成运算任务，适合在后台运算且不需要太多交互的任务。

4. ##### Serial Old 收集器

   Serial收集器的老年代版本，**单线程**，使用**标记-整理算法**。主要意义是被Client模式下的虚拟机使用。在Server模式下，有两个用处：

   - 在JDK1.5及之前版本中来搭配新生代的Parallel Scavenge收集器使用；
   - 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候启用。

5. ##### Parallel Old收集器

   是Parallel Scavenge收集器的老年代版本，**多线程**，**标记-整理算法**。

   在JDK1.5及之前，如果新生代选择Parallel Scanvege收集器，由于不能和CMS配合工作，所以老年代只有Serial Old收集器一个选择，但是Serial Old收集器由于单线程的原因回收效率太低，无法充分利用多CPU的硬件环境。

   在Parallel Old收集器出现后，Parallel Scavenge + parallel Old成为在注重吞吐量和CPU资源敏感的场合优先考虑的组合。

6. ##### CMS收集器

   Concurrent Mark Sweep收集器，**用于老年代**，采用**标记-清除算法**，是一种以获取最短回收停顿时间为目标的收集器。适用于java应用对于服务响应速度有很高需求，尽可能快给用户反馈的需求。

   所谓最短回收停顿时间，是基于前面几种收集器而言的。之前提到的收集器，为了避免一边回收垃圾，并行的线程一边产生“垃圾”的问题，在垃圾回收时都采用暂停所有其他线程的方法，也就是说整个应用都会sleep一段时间。势必会影响程序整体效率。CMS采用的方法虽然也会有stop the world的情况，但比前几种收集器的停顿时间要短得多。流程主要分四步：

   - 初始标记

     需要**暂停所有用户线程**，**单线程操作**，目的是**标记GC Roots能直接关联到的对象**，并非所有对象，因为对象比较少，速度比标记所有对象**快**很多；

   - 并发标记

     **并发**，**单线程操作**，书中解释的名词叫GC Roots Tracing，我的理解就是**在初始标记的基础上遍历完所有引用链**，操作对象比初始标记阶段多，故**慢**；

   - 重新标记

     需要**暂停所有用户线程**，**多线程操作**，目的是修正并发标记期间因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，即**记录并发时其他线程产生的“垃圾”**。时间比初始标记稍长，远短于并发标记时间；

   - 并发清除

     **并发**，**单线程操作**，对未标记对象执行清除操作，时间较长。

   整个过程中耗时最长的并发标记和并发清除两个阶段都是并发执行，所以CMS收集器停顿时间比其他几种收集器都短得多。CMS收集器的缺点如下：

   - 对CPU资源敏感。由于和用户线程并发执行，会占用一部分用户线程数（或CPU资源），导致应用程序变慢，总吞吐量降低。CMS默认启动的线程数是(CPU数量+3)/4，CPU在四个以上时，并发回收的线程最多占用不超过25%的CPU资源；但CPU不足4个时，划分给CMS的CPU资源会趋向一半甚至更多，也就相当于用户程序执行速度降低了一半。为此出现了i-CMS：增量式并发收集器来解决这个问题。即在并发标记和并发清除阶段，让GC线程、用户线程交替运行，尽量减少GC线程持续占有一部分资源的时间，类似于单CPU时代的线程“并行”处理办法。这样整个垃圾回收时间会更长，但对用户程序影响会显得少一些。目前版本i-CMS已不再提倡用户使用。
   - 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”而导致另一次Full GC的产生。由于CMS并发收集时用户线程还在执行，所以不能等内存空间几乎满了再进行收集，需要预留一部分空间用户并发回收时的用户线程使用。如果在执行并发回收时，预留的空间无法满足用户线程需要，就会出现“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案，临时启用Serial Old重新对老年代进行GC，效率将会变得很差。CMS收集器默认的预留空间是68%，参数 -XX:CMSInitiatingOccupancyFrantion用来控制触发CMS回收的百分比，如果老年代增长不是很快可以适当调高，但太高的话会使预留空间过小导致频繁切换Serial Old。
   - 采用的标记-清除算法会产生内存碎片。如果碎片过多，大对象进入老年代时连续空间不够将提前触发Full GC。-XX:+UseCMSCompactAtFullCollection开关参数用于在Full GC之后增加一个无法并发的碎片整理过程。

7. ##### G1收集器

   Garbage First，最新。

   相比于CMS的改进：采用**标记-整理算法**，不会产生空间碎片；精确控制停顿，可以明确设置在长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。

   G1收集器将包含新生代和老年代的整个Java堆划分为多个大小固定的独立区域（Region），并跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，挑选垃圾最多的区域进行收集，从而可以实现在基本不牺牲吞吐量的前提下完成低停顿的垃圾回收。



以下整理垃圾收集相关的JVM设置参数：

| 参数                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | JVM在Client模式下的默认值，打开此开关，使用Serial + Serial Old组合 |
| UseParNewGC                    | 打开此开关，使用ParNew + Serial Old组合                      |
| UseConcMarkSweepGC             | 打开此开关，使用ParNew + CMS组合                             |
| UseParallelGC                  | JVM在Server模式下的默认值，打开此开关，使用Parallel Scavenge + Serial Old(PS MarkSweep)组合 |
| UseParallelOldGC               | 打开此开关，使用Parallel Scavenge + Parallel Old组合         |
| SurvivorRatio                  | 新生代中Eden区域与Survivor区域的容量比值，默认为8，Eden:Suevivor=8:1 |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，大于此参数的对象将直接在老年代分配 |
| MaxTenuringThreshold           | 晋升到老年代的对象年龄，对象年龄超过此参数则进入老年代       |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小以及进入老年代的年龄           |
| HandlePromotionFailure         | 是否允许分配担保失败                                         |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数，默认为(CPU数量+3)/4        |
| GCTimeRatio                    | GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅用于Parallel Scavenge |
| MaxGCPauseMills                | 设置GC最大停顿时间。仅用于Parallel Scavenge                  |
| CMSInitiatingOccupancyFrantion | 设置CMS在老年代空间被使用多少后出发垃圾收集，默认值68%，仅用于CMS |
| UseCMSCompactAtFullCollection  | 设置CMS在完成垃圾收集后是否进行内存碎片整理，仅用于CMS       |
| CMSFullGCsBeforeCompaction     | 设置CMS在进行多少次垃圾收集后再启动一次内存碎片整理，仅用于CMS |

